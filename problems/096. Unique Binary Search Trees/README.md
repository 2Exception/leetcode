# 96. Unique Binary Search Trees

## #1 动态规划(AC)

我们首先需要知道左右子树各用了多少个节点用于构造树，由于二叉搜索的特点，左子树的节点值都小于根节点，右子树的节点值都大于根节点，所以我们只需要去枚举各个可能的根节点，然后求出`左子树所有的不同的二叉树`*`右子树所有的不同的二叉树`即可。而没棵子树上所有的二叉树的数量只取决于该子树的节点数，所有我们可以用`dp[i]`来存储用`i`个节点能构造出的不同的二叉搜索树的个数。

```java
class Solution {
    public int numTrees(int n) {
        if(n <= 0)
            return 0;
        int[] dp = new int[n+1]; //dp[i]代表有i个节点，能构成多少个不同的二叉搜索树，最终要返回的是dp[n];
        dp[0] = 1;
        dp[1] = 1;
        for(int i=2; i<=n; i++){ //i代表节点个数 dp[2] dp[3] dp[4] ... dp[n]
            for(int r=1; r<=i; r++){
                dp[i] += (dp[r-1] * dp[i-r]); // left * right
            } 
        }
        return dp[n];
    }
}
```

#### 复杂性分析：

- **时间复杂性：**$O(n^2)$

- **空间复杂性：**$O(n)$

  ​